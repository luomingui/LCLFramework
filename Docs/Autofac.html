<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>Autofac-LCL框架文档</title>
    <link href="css/bootstrap.min.css" rel="stylesheet" type="text/css" />
    <link href="css/lcl.css" rel="stylesheet" type="text/css" />
</head>

<body>
    <div class="navheader">
        <table width="100%" summary="Navigation header">
            <tr>
                <th colspan="3" align="center" style="text-align: center;">Autofac</th>
            </tr>
            <tr>
                <td width="20%" align="left">
                    <a accesskey="p" href="Debugging.html">Prev</a>&nbsp;
                </td>
                <th width="60%" align="center">&nbsp;</th>
                <td width="20%" align="right">
                    &nbsp;
                    <a accesskey="n" href="Logging.html">Next</a>
                </td>
            </tr>
        </table><hr />
    </div>

    <div class="document-contents">
        <h3 id="DocServerSide">Autofac依赖注入分析</h3>
        <p>通过Autofac对接口依赖的实现进行注入，需要用到的核心类如下</p>
        <img src="images/Autofac.png" />
        <p>
            可以看到这里面相关的类为<br />
            mvcApplication<br />
            IEngine，LEngine<br />
            EngineContext<br />
            IDependencyRegistrar，DependencyRegistrar<br />
            下面我们再来看看这些类的核心代码。<br />
            每个项目里都有一个DependencyRegistrar，其作用就是调用Autofac相关的API进行依赖注入，
            我们只要打开这个类文件，搜索一个指定的接口，就可以找到它依赖的具体类。
            例如，我们想看到ICategoryService接口是依赖哪一个实现，
            在这个类中搜索ICategoryService，会找到下面的代码：
        </p>
        <pre>
builder.RegisterType&lt;CategoryService&gt;().As&lt;ICategoryService&gt;().InstancePerLifetimeScope();
</pre>
        <p>
            可以看到这个接口对应的实现为为CategoryService<br />
            下面我们来看看在网站启动是怎么调用这个DependencyRegistrar类呢？
        </p>
        <p>
            在项目就是前台的起始项目有一个文件Global.asax里有一个函数Application_Start，这函数的意义这里就不用说了，
            我相信学过ASP.NET同学都知道它的作用，下面是函数Application_Start的完整代码：
        </p>
        <pre>
protected void Application_Start()
{ 
    //initialize engine context
    EngineContext.Initialize(false);

    //model binders
    ModelBinders.Binders.Add(typeof(BaseNopModel), new NopModelBinder());

    //Add some functionality on top of the default ModelMetadataProvider
    ModelMetadataProviders.Current = new NopMetadataProvider();

    //Registering some regular mvc stuff
    AreaRegistration.RegisterAllAreas();// 注册区域路由
    RegisterRoutes(RouteTable.Routes);// 注册项目路由
}
</pre>
        <p>里面有第一行代码就调用了上下文引擎初始化。 </p>
        <pre>
//initialize engine context
EngineContext.Initialize(false);
</pre>
        <p>下面我们来看看这个EngineContext的静态方法Initialize：</p>
        <pre>
[MethodImpl(MethodImplOptions.Synchronized)]
public static IEngine Initialize(bool forceRecreate)
{
    if (Singleton&lt;IEngine&gt;.Instance == null || forceRecreate)
    {
        var config = ConfigurationManager.GetSection("LConfig") as LConfig;
        Singleton&lt;IEngine&gt;.Instance = CreateEngineInstance(config);
        Singleton&lt;IEngine&gt;.Instance.Initialize(config);

        Singleton&lt;LclStartupConfiguration&gt;.Instance.Initialize();
    }
    return Singleton&lt;IEngine&gt;.Instance;
}
protected static IEngine CreateEngineInstance(LConfig config)
{
    if (config != null && !string.IsNullOrEmpty(config.EngineType))
    {
        var engineType = Type.GetType(config.EngineType);
        if (engineType == null)
            throw new ConfigurationErrorsException("The type '" + config.EngineType + "' could not be found. Please check the configuration at /configuration/nop/engine[@engineType] or check for missing assemblies.");
        if (!typeof(IEngine).IsAssignableFrom(engineType))
            throw new ConfigurationErrorsException("The type '" + engineType + "' doesn't implement 'LCL.Core.Infrastructure.IEngine' and cannot be configured in /configuration/nop/engine[@engineType] for that purpose.");
        return Activator.CreateInstance(engineType) as IEngine;
    }
    return new LEngine();
}
</pre>
        <p>
            从上面可以看到Initialize返回一个IEngine的实例，并调用其方法Initialize。
            创建IEngine的实例是根据配置文件来获取哪一个IEngine的具体类，如果没有配置这个结点信息或者为空，
            则返回默认的IEngine的实现LEngine。
        </p>
        <p>下面我们来看看LCL.Infrastructure.LEngine里面的核心代码：</p>
        <pre>
public void Initialize(LConfig config)
{
     //注册依赖
     RegisterDependencies(config);
 
     //startup tasks
     if (!config.IgnoreStartupTasks){
          RunStartupTasks();
     }
}
protected virtual void RegisterDependencies(NopConfig config)
{
     var builder = new ContainerBuilder();
     var container = builder.Build();
 
     //we create new instance of ContainerBuilder
     //because Build() or Update() method can only be called once on a ContainerBuilder.
 
 
     //dependencies&lt;IEngine&gt;
     var typeFinder = new WebAppTypeFinder(config);
     builder = new ContainerBuilder();
     builder.RegisterInstance(config).As&lt;LConfi&gt;().SingleInstance();
     builder.RegisterInstance(this).As&lt;IEngine&gt;().SingleInstance();
     builder.RegisterInstance(typeFinder).As&lt;ITypeFinder&gt;().SingleInstance();
     builder.Update(container);
 
     //register dependencies provided by other assemblies
     builder = new ContainerBuilder();
     //查找所有实现了接口IDependencyRegistrar的类
     var drTypes = typeFinder.FindClassesOfType&lt;IDependencyRegistrar&gt;();
     var drInstances = new List&lt;IDependencyRegistrar&gt;();
     foreach (var drType in drTypes)
          drInstances.Add((IDependencyRegistrar) Activator.CreateInstance(drType));
     //排序
     drInstances = drInstances.AsQueryable().OrderBy(t => t.Order).ToList();
     //依次调用实现IDependencyRegistrar接口的类的方法Register
     foreach (var dependencyRegistrar in drInstances)
          dependencyRegistrar.Register(builder, typeFinder);
     builder.Update(container);
 
     this._containerManager = new ContainerManager(container);
 
     //set dependency resolver
     DependencyResolver.SetResolver(new AutofacDependencyResolver(container));
}
</pre>

    </div>

    <div class="navfooter">
        <hr /><table width="100%" summary="Navigation footer">
            <tr>
                <td width="40%" align="left"><a accesskey="p" href="Debugging.html">Prev</a>&nbsp;</td>
                <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a>&nbsp;</td>
                <td width="40%" align="right"><a accesskey="n" href="Logging.html">Next</a>&nbsp;</td>
            </tr>
        </table>
    </div>
</body>
</html>
